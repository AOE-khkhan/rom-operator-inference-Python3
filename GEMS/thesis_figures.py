import numpy as np
import h5py 
import matplotlib.pyplot as plt
import OpInf_Model
import opinf_helper

#for latex
plt.rc('text', usetex=True)
plt.rc('font', family='serif')

#font sizes
plt.rc('xtick',labelsize=35)
plt.rc('ytick',labelsize=35)
plt.rc('axes',labelsize=40)


def cumulative_energy_plots(eigenvalues = None, compute = False, X = np.empty(1), n_to_plot = 50):
	'''
	This function computes and/or plots the cumulative energy of the singular values using the eigenvalues of X^T*X.
	Special markers for the sv with 97.5% and 99% energy
	--------------------
	INPUT
	--------------------
	eigenvalues: array [n_values, 1] (optional, default = None)
			1 dimensional array of eigenvalues
			if eigenvalues = None, must pass a dataset for X and compute = True

	compute: boolean  (optional, default = False)
			True - compute the eigenvalues of X^T*X (singular values of X)
				must pass True if eigenvalues = None
				this will save the eigenvalues and eigenvectors in an hdf5 file called 'Eigen_nt%d' d = n_samples
			False - don't compute (eigenvalues need to be passed as argument 'eigenvalue')

	X: array [n_variables, n_samples] (optional, default = 1d empty array)
			2 dimensional array of data to compute singular values of
			must pass an argument if eigenvalues = None 

	n_to_plot: int (optional, default = 50)
			Numer of singular values to plot 



	--------------------
	OUTPUT
	--------------------
	None - a plot of the cumulative energy

	'''

	if eigenvalues == None:
		assert compute == True, 'No eigenvalues passed, must set compute = True and pass a dataset, X'
		assert len(X.shape) ==2, 'No eigenvalues passed, must pass a 2d dataset for X'

		#compute eigendecomp of X^T * X
		XTX = (X.T)@X
		[eigenvalues,EigVec] = np.linalg.eig(XTX)

		#Save eigendecomp
		hf = h5py.File("Eigen_nt%d.h5" %X.shape[1],'w')
		hf.create_dataset('values',data=eigenvalues)
		hf.create_dataset('vectors',data=EigVec)
		hf.close()	



	#compute cumulative energy 
	su = np.sum(eigenvalues)
	energy = np.cumsum(eigenvalues)/su

	#find where 97.5 and 99 percent energy are
	cutoffs975 = np.where(energy>.975)
	cutoffs99 = np.where(energy>.99)
	idx99 = cutoffs99[0][0]
	idx975 = cutoffs975[0][0]

	plt.figure(trainsize)
	plt.scatter(range(idx975), energy[:idx975], s=200,c = 'k',marker = 'o')
	plt.scatter(range(idx975+1,idx99), energy[idx95+1:idx99], s=200,c='k',marker = 'o')
	plt.scatter(range(idx99+1,40), energy[idx99+1:], s=200, c='k',marker = 'o')


	plt.scatter(idx975,energy[idx975],s = 200,c='r',marker = '^', label = '0.975')
	plt.scatter(idx99,energy[idx99],s = 200,c='g',marker = 's', label = '0.99')

	plt.grid()
	plt.ylim([0.78,1.005])
	plt.legend(loc = 'lower right',fontsize = 35)
	plt.xlabel("Singular Value Index",fontsize = 40)
	plt.ylabel("Cumulative Energy",fontsize = 40)
	plt.xticks(fontsize = 35)
	plt.yticks(fontsize = 35)
	plt.show()

def projection_error_plots(r_vals, compute = False, nt = 5000):
	''' 
		Compute and plot the projection error versus basis size 
		|| X - VV^TX||/||X||

		This function requires 
			reduced data to be in "data/data_reduced_minmax_nt%d" %nt
			full dimensional data to be in "data/data_minmax.h5"
			svd to be in "data/svd_nt%d.h5" %nt

		These files can be generated by typing in the command prompt 'python3 projection_helpers.py'

		If the projection error is saved already you can run precomputed_projection_error_plots below
	--------------------
	INPUT
	--------------------
	r_vals: list/1d array of integers
			the basis sizes to compute projection error for 

	compute: boolean  (optional, default = False)
			True - compute the projection error 

	nt: int (optional,default = 5000)
			number of snapshots from "data/data_reduced_minmax_nt%d" %nt to 



	--------------------
	OUTPUT
	--------------------
	None - a plot of the cumulative energy 

	Run the commented code to compute projection error, but it takes a long time.
		I have already run it and saved the output below for nt = 10000
	'''


	datafilefolder = "data/data_reduced_minmax_nt%d" %nt

	fulldatapath = "data/data_minmax.h5"
	f_true_data = h5py.File(fulldatapath)
	data = f_true_data['data'][:,:nt]
	f_true_data.close()

	print("Done loading true data")

	svd_filepath = 'data/svd_nt%d.h5' %nt

	'''Load SVD data'''
	hf = h5py.File(svd_filepath)
	Und = hf['U'][:,:]
	Snd = hf['S'][:]
	hf.close()
	print("Done loading svd_filepath")

	den = np.linalg.norm(data,'fro')**2
	print("Done computing data norm")



	# plt.show()
	# # err =np.zeros(len(r_vals))

	# # for i,r in enumerate(r_vals):
	# # 	print("r = ", r)
	# # 	fdata = h5py.File("%s/data_reduced_%d.h5" %(datafilefolder,r),'r')
	# # 	xhat1 = fdata['data'][:,:2500]
	# # 	err1 = np.linalg.norm((data[:,:2500] - (Und[:,:r]@xhat1)),'fro')**2
	# # 	xhat1 = fdata['data'][:,2500:5000]
	# # 	err2 = np.linalg.norm((data[:,2500:5000] - (Und[:,:r]@xhat1)),'fro')**2
	# # 	xhat1 = fdata['data'][:,5000:7500]
	# # 	err3 = np.linalg.norm((data[:,5000:7500] - (Und[:,:r]@xhat1)),'fro')**2
	# # 	# xhat1 = fdata['data'][:,7500:]
	# # 	# err4 = np.linalg.norm((data[:,7500:] - (Und[:,:r]@xhat1)),'fro')**2
	# # 	err[i] = (err1 + err2 + err3 ) / den
	# # 	# err[i] = err1/den
	# # 	print(err[i])
	# # print(err)
	# # plt.plot(r_vals,err,marker = 'o',markersize = 11)
	# # plt.yticks(fontsize = 20)
	# # plt.xticks(fontsize = 20)
	# # plt.xlabel("Basis Size",fontsize = 25)
	# # plt.ylabel("Relative Projection Error",fontsize = 25)
	# # plt.grid()
	# # plt.show()

def precomputed_projection_error_plots_nt():
	'''
	plot the precomputed projection errors shown in the thesis
	'''
	### PLOT 10000
	plt.figure(10000)
	r_vals = [17,18,19,20,21,22,23,24,25,26,27,28,29,30,35,40,45,50,55,60]
	err = [0.02623978,0.02426045,0.02237011,0.02063133,0.01914182,0.01774004,0.01640272,0.01516237,0.01409079,0.01306348,0.01218935,0.01131679,0.01047433,0.00973932,0.00677672,0.00475579,0.00340463,0.00246246,0.0018381,0.00137202]
	plt.semilogy(r_vals,err,marker = 'o',markersize = 11)
	plt.yticks(fontsize = 35)
	plt.xticks(fontsize = 35)
	plt.xlabel("Basis Size",fontsize = 40)
	plt.ylabel("Relative Projection Error",fontsize = 40)
	plt.grid()
	# plt.show()

	### PLOT 5000
	plt.figure(5000)
	r_vals = [5,6,7,8,9,10,11,12,13,14,15,20,25,30,35,40]
	err = [0.05332193739090479,0.03876918702112699,0.03117067633558608,0.025603912692953833,0.021500925935262,0.018501304896980528,0.015670068912441684,0.013442136887019942,0.011585637332676278,0.010134284788878288,0.008846817612083262,0.004378848820814475,0.002295618662286883,0.001305633374020862,0.0007664673959594354,0.00045899099951707387]
	plt.plot(r_vals,err,marker = 'o',markersize = 11)
	plt.yticks(fontsize = 35)
	plt.xticks(fontsize = 35)
	plt.xlabel("Basis Size",fontsize = 40)
	plt.ylabel("Relative Projection Error",fontsize = 40)
	plt.grid()
	# plt.show()

	### PLOT 2500
	plt.figure(2500)
	r_vals = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,20,25]
	err = [0.13848034352309818,0.07997648696325324,0.047701239123391095,0.02937232423016965,0.021283972595306365,0.015898899728508168,0.012073162112056512,0.00902982469782239,0.006713842181710916,0.005171785614887142,0.003958874898184814,0.0030843009343440473,0.002451214184749234,0.00196786622873802,0.001600982873616694,0.0006058349290951089,0.00026008757151678696]
	plt.plot(r_vals,err,marker = 'o',markersize = 11)
	plt.yticks(fontsize = 35)
	plt.xticks(fontsize = 35)
	plt.xlabel("Basis Size",fontsize = 40)
	plt.ylabel("Relative Projection Error",fontsize = 40)
	plt.grid()
	# plt.show()


	### PLOT 7500
	plt.figure(7500)
	err = [0.02478917, 0.02225193, 0.01342808, 0.00816962, 0.00516766, 0.00331283, 0.00219629, 0.00149791, 0.00103855]
	r_vals = [14,15,20,25,30,35,40,45,50]
	plt.plot(r_vals,err,marker = 'o',markersize = 11)
	plt.yticks(fontsize = 35)
	plt.xticks(fontsize = 35)
	plt.xlabel("Basis Size",fontsize = 40)
	plt.ylabel("Relative Projection Error",fontsize = 40)
	plt.grid()
	plt.show()

def avg_error_vs_r_plots():
	r_vals = [17,19,20,21,23,25,26,27,28,29]
	# err = np.zeros((len(r_vals),8))
	names=['P','U','V','T','CH4','O2','CO2','H2O']
	err = np.array([  [0.01454766, 9.49088701, 3.8416807,  0.1408219,  0.01492752, 0.07447026, 0.06306458, 0.05171251],
						  [0.00778793, 7.22159941, 3.69146352, 0.12826844, 0.01288493, 0.06671221, 0.05784904, 0.04569186],
						  [0.00806599, 7.41350499, 3.73769771, 0.12793652, 0.01241257, 0.06744112, 0.05791651, 0.04616134],
						  [0.00805222, 6.75203464, 3.40937395, 0.12354269, 0.0124864,  0.06493066, 0.05597273, 0.04455494],
						  [0.0091237,  6.58027839, 3.28230807, 0.11394456, 0.01227672, 0.06195188, 0.05268158, 0.04276572],
						  [0.00975837, 5.87004708, 3.31902309, 0.10892118, 0.01280862, 0.05783345, 0.0488222,  0.03995414],
						  [0.00857549, 5.43155896, 3.22373671, 0.10827142, 0.01188191, 0.05796642, 0.04978544, 0.03965885],
						  [0.00831206, 6.40176765, 3.2343913,  0.10845626, 0.01249052, 0.05695861, 0.04853448, 0.03918773],
						  [0.00781415, 4.99844264, 3.16241525, 0.10234087, 0.01051424, 0.05425908, 0.04712304, 0.03703371],
						  [0.00589345, 4.69447412, 3.01386057, 0.09138204, 0.00997636, 0.04798934, 0.04138459, 0.03288728]])



	xtic = [17,19,21,23,25,27,29]
	fig = plt.figure(1)
	ax = fig.add_subplot(111)    # The big subplot
	ax1 = fig.add_subplot(2,2,1)
	ax1.plot(r_vals,err[:,0],'-o', label = 'P')
	ax1.legend(fontsize = 25)
	ax1.set_xticks(xtic)
	ax1.set_yticklabels(['0.01','0.012','0.014','0.016'])
	# ax1.ticklabel_format(style = 'sci',axis = 'y')
	ax1.set_ylabel("Relative Error",fontsize = 30)
	# plt.xlabel("Basis Size")
	ax1 = fig.add_subplot(2,2,2)
	ax1.plot(r_vals,err[:,3],'-o', label = 'T')
	ax1.set_xticks(xtic)
	ax1.legend(fontsize = 25)
	ax1 = fig.add_subplot(2,2,3)
	ax1.plot(r_vals,err[:,1],'-o', label = 'U')
	ax1.set_xticks(xtic)
	ax1.set_yticks([6,8,10])
	ax1.set_yticklabels(['6.0','8.0','10.0'])
	ax1.legend(fontsize = 25)
	plt.ylabel("Absolute Error",fontsize = 30,labelpad = 20)
	# plt.xlabel("Basis Size")
	ax1 = fig.add_subplot(2,2,4)
	ax1.plot(r_vals,err[:,2],'-o', label = 'V')
	ax1.set_xticks(xtic)
	ax1.legend(fontsize = 25)
	ax.spines['top'].set_color('none')
	ax.spines['bottom'].set_color('none')
	ax.spines['left'].set_color('none')
	ax.spines['right'].set_color('none')
	ax.tick_params(labelcolor='w', top='off', bottom='off', left='off', right='off')
	# ax.set_ylabel("Relative Absolute Error", labelpad = 30, fontsize = 30)
	ax.set_xlabel("Basis size", fontsize = 30)

	# plt.show()



	# fig = plt.figure(2)
	# ax = fig.add_subplot(111)    # The big subplot
	# ax1 = fig.add_subplot(1,2,1)
	# ax1.plot(r_vals,err[:,1],'-o', label = 'U')
	# ax1.set_xticks(xtic)
	# ax1.legend(fontsize = 25)
	# plt.ylabel("Average Absolute Error",fontsize = 30)
	# # plt.xlabel("Basis Size")
	# ax1 = fig.add_subplot(1,2,2)
	# ax1.plot(r_vals,err[:,2],'-o', label = 'V')
	# ax1.set_xticks(xtic)
	# ax1.legend(fontsize = 25)
	# ax.spines['top'].set_color('none')
	# ax.spines['bottom'].set_color('none')
	# ax.spines['left'].set_color('none')
	# ax.spines['right'].set_color('none')
	# ax.tick_params(labelcolor='w', top='off', bottom='off', left='off', right='off')
	# # ax.set_ylabel("Relative Absolute Error", labelpad = 20, fontsize = 20)
	# ax.set_xlabel("Basis size", fontsize = 30)
	# # plt.show



	fig = plt.figure(3)
	ax = fig.add_subplot(111)    # The big subplot
	ax1 = fig.add_subplot(2,2,1)
	ax1.plot(r_vals,err[:,4],'-o',label = 'CH4')
	plt.legend(fontsize = 25)
	ax1.set_xticks(xtic)
	ax1 = fig.add_subplot(2,2,2)
	ax1.plot(r_vals,err[:,5],'-o',label = 'O2')
	plt.legend(fontsize = 25)
	ax1.set_xticks(xtic)
	ax1 = fig.add_subplot(2,2,3)
	ax1.plot(r_vals,err[:,6],'-o',label = 'CO2')
	plt.legend(fontsize = 25)
	ax1.set_xticks(xtic)
	ax1 = fig.add_subplot(2,2,4)
	ax1.plot(r_vals,err[:,7],'-o',label = 'H2O')
	plt.legend(fontsize = 25)
	ax1.set_xticks(xtic)
	ax.spines['top'].set_color('none')
	ax.spines['bottom'].set_color('none')
	ax.spines['left'].set_color('none')
	ax.spines['right'].set_color('none')
	ax.tick_params(labelcolor='w', top='off', bottom='off', left='off', right='off')
	ax.set_ylabel("Normalized Absolute Error", labelpad = 30, fontsize = 30)
	ax.set_xlabel("Basis size", fontsize = 30)
	plt.show()

def integrated_species_plot():
	time = np.linspace(0.015,0.016,10000)
	true = np.loadtxt("results/true_integral_species")
	fig = plt.figure(5)
	ax = fig.add_subplot(111)    # The big subplot
	names = ['CH4','O2','CO2','H2O']
	for i in range(4):
		sub=i+1
		ax1 = fig.add_subplot(2,2,sub)
		ax1.set_title(names[i],fontsize = 25)
		ax1.plot(time,true[i,:],label = 'true',linewidth = 3,color='k')
		ax1.set_xticks([])


		r1 = 17
		estimate = np.loadtxt("results/integral_species_r%d_nt10000_l30000" %r1)	
		ax1.plot(time,estimate[i,:],linestyle = '--',linewidth = 3,label = "r=%d" %r1 )

		r2 = 29
		estimate = np.loadtxt("results/integral_species_r%d_nt10000_l30000" %r2)	
		ax1.plot(time,estimate[i,:],linestyle = '-.',linewidth = 3,label = "r=%d" %r2 )

		if sub == 2:
			ax1.legend(loc='upper center', bbox_to_anchor=(-0.11, 1.38), ncol=6)
		if sub == 3 or sub == 4:
			ax1.set_xticks([0.015,0.0155,0.016])

		# plt.xlabel("Time (s)",fontsize = 15)
		# plt.ylabel("Integrated Molar Concentration (kmol/m^3)", fontsize = 15)
		# plt.text(0.4,0.5,'Common Y', va = 'center',rotation = 'vertical')
		# plt.legend() 
		# Shrink current axis by 20%
		# box = ax.get_position()
		# ax1.set_position([box.x0, box.y0, box.width * 0.8, box.height])

		# Put a legend to the right of the current axis
	# Put a legend below current axis
	# ax1.legend(loc='center left', bbox_to_anchor=(1, 0.5))

	ax.spines['top'].set_color('none')
	ax.spines['bottom'].set_color('none')
	ax.spines['left'].set_color('none')
	ax.spines['right'].set_color('none')
	ax.tick_params(labelcolor='w', top='off', bottom='off', left='off', right='off')
	ax.set_ylabel("Integrated Molar Concentration (kmol/m^3)", labelpad = 25, fontsize = 23)
	ax.set_xlabel("Time (s)", fontsize = 23)
	plt.show()

def L_curves():
	k_ridge = [1e3,1e4,3e4,5e4,1e5,3e5,5e5]#,1e6,3e6,5e6]
	# k_ridge = [1e4,3e4,5e4,1e5,3e5,5e5]
	colors = plt.cm.jet(np.linspace(0,1,len(k_ridge)))
	markers = ["P","o","^","s","*","D","+","p",">","<"]
	r_vals = [29]#,30,35,40,45]

	train_time = 10000
	forecast_time = 20000-train_time

	datafilefolder = "data/data_reduced_minmax_nt%d" %train_time
	fulldatapath = "data/data_minmax.h5"
	svd_filepath = 'data/svd_nt%d.h5' %train_time


	#--------------------------------------------
	#			USER INPUTS END
	#--------------------------------------------

	Nfull = 308184 		#length of full state
	N = 38523			#length of each variable

	total_time = np.linspace(0.015,0.017,20000) #Time steps for all 20000 
	dt = 1e-7


	hf = h5py.File(svd_filepath)
	Und = hf['Und'][:,:max(r_vals)] 			#Singular vectors
	hf.close()



	# define arrays for saving error
	relative_error_over_domain = np.zeros((len(r_vals),len(k_ridge),8))

	log_res = np.zeros((len(k_ridge),len(r_vals)))
	log_sol = np.zeros((len(k_ridge),len(r_vals)))


	#input function
	U = lambda t: 1e6*(1+0.1*np.sin(2*np.math.pi*5000*t))	#define the input function

	fig = plt.figure()
	ax = plt.gca()
	for kidx,k in enumerate(k_ridge):
		
		print("Regularization parameter = %1.1f" %k)

		for idx,r in enumerate(r_vals):
			print("POD basis dimension = ", r)



			# fdata = h5py.File("data/data_reduced_minmax/data_reduced_%d.h5" %r,'r')
			fdata = h5py.File("%s/data_reduced_%d.h5" %(datafilefolder,r),'r')
			xhat = fdata['data'][:,:train_time]
			# fxdot = h5py.File("data/xdot_reduced_minmax/xdot_reduced_%d.h5" %r,'r')
			fxdot = h5py.File("%s/xdot_reduced_%d.h5" %(datafilefolder,r),'r')
			xdot = fxdot['xdot'][:,:train_time]
			fdata.close()
			fxdot.close()

			'''
			------------------------
			Define the model 
			------------------------
			'''
			mymodel = OpInf_Model.model('LQ',True) 					# a linear quadratic with input


			'''
			------------------------
			Fit the model 
			------------------------
			'''
			mymodel.fit(r,k,xdot,xhat,U(total_time[:train_time]))
			# A,H,B = mymodel.get_operators()

		

			log_res[kidx,idx],log_sol[kidx,idx] = mymodel.get_residual_norm()

			ax.scatter(log_sol[kidx,idx],log_res[kidx,idx],c = colors[kidx],s = 400,marker = markers[kidx],label = r'$\lambda = $%.1E' %k)
			ax.set_yscale('log')
			ax.set_xscale('log')
	ax.set_xlabel(r'$\Vert \mathbf{O}^T \Vert^2_2$',fontsize = 40)
	ax.set_ylabel(r'$\Vert  \mathbf{D}\mathbf{O}^T - \dot{\hat{\mathbf{X}}}\Vert_2^2$',fontsize = 40)
	plt.subplots_adjust(left=0.16, bottom = .15, right = 0.95)
	ax.grid()
	ax.legend(loc = 'upper right', fontsize = 30)
	plt.show()

def plot_condition_number():
	colors = ['r','o','b','k']
	markers = ['s','*','o','^']

	r_vals = [5,10,15,20,25,30]

	train_time = [2500,5000,7500,10000]
	total_time = np.linspace(0.015,0.017,20000) #Time steps for all 20000 


	#input function
	U = lambda t: 1e6*(1+0.1*np.sin(2*np.math.pi*5000*t))	

	for idx,tt in enumerate(train_time):
		print("Train time = ", tt)

		datafilefolder = "data/data_reduced_minmax_nt%d" %tt

		condition = np.zeros(len(r_vals))

		for idx_r,r in enumerate(r_vals):
			print("POD basis dimension = ", r)

			fdata = h5py.File("%s/data_reduced_%d.h5" %(datafilefolder,r),'r')
			xhat = fdata['data'][:,:tt]
			fdata.close()

			X2 = opinf_helper.get_x_sq(xhat.T)

			D = np.hstack((xhat.T,X2,np.atleast_2d(U(total_time[:tt])).T))

			print("Shape of data matrix")
			condition[idx_r] = np.linalg.cond(D)

		plt.semilogy(r_vals,condition,marker = markers[idx],linewidth = 2.5,markersize = 20, label = r'$n_{\textrm{train}} = $%d' %tt)
	plt.legend(fontsize = 35)
	plt.xlabel("Basis Size")
	plt.ylabel(r'cond($\mathbf{D}$)')
	plt.show()

def time_traces():
	time_trace_folders = ["Monitor_Location_0_225","Monitor_Location_60_225","Monitor_Location_0_12","Monitor_Location_n20_10"]
	k_ridge = [[3e5,5e5],[3e4,5e4,1e5,3e5],[3e4,5e4,1e5],[3e4,5e4,1e5]]
	r_vals = [[5,8],[9,15],[13,22],[17,29]]
	train_time = [2500,5000,7500,10000]

	#(0,22.5), (60,22.5), (0, 12), (-20,10)
	cheng_elements_to_plot = ['7','10','6','3']

	for ele_idx,element_to_plot in enumerate(cheng_elements_to_plot):
		truth = np.loadtxt('../chengs_data/TimeTraceData/point_mon_%s.txt' %element_to_plot, delimiter = ",")
		time_steps = truth[:,0]
		for idx,current_r_vals in enumerate(r_vals):
			tt = train_time[idx]
			for r in current_r_vals:
				for k in k_ridge[idx]:
					xr = np.loadtxt('timetraces/%s/r%d_k%d_train%d.txt' %(time_trace_folders[ele_idx],r,k,tt))

					plt.figure()
					plt.plot(time_steps, xr,linestyle = '--', linewidth=2,label='ROM, r = %d' %r)
					plt.plot(time_steps, truth[:,1],linewidth=2,label = "TRUE")

					plt.plot(np.ones(300)*time_steps[tt-1], np.linspace(min(np.minimum(truth[:,1],xr)), max(np.maximum(truth[:,1],xr)),300),color='black')
					plt.xlabel("Time (s)",fontsize = 20)
					plt.xticks(fontsize = 15)
					plt.yticks(fontsize = 15)
					plt.ylabel("Pressure",  fontsize = 20)
					plt.ticklabel_format(style='sci',axis = 'y',scilimits=(0,0))
					plt.legend(fontsize=10)
					plt.savefig('timetraces/%s/r%d_k%d_train%d.pdf' %(time_trace_folders[ele_idx],r,k,tt),bbox_inches="tight", format='pdf',dpi=300)
					plt.clf()

def unphysical_values():
	unp = np.load("Unphysical_Values_Timestep.npy")
	plt.figure(1)
	plt.plot(unp[0,:],linewidth = 2,label = "pressure")
	plt.plot(unp[3,:],linewidth = 2,label = "specific volume")
	plt.xlabel("Time step", fontsize = 30)
	plt.ylabel("Number of negative values predicted", fontsize = 30)
	plt.legend(fontsize = 25)

	plt.figure(2)
	plt.plot(unp[4,:],linewidth = 2,label = "CH4")
	plt.plot(unp[5,:],linewidth = 2,label = "O2")
	plt.plot(unp[6,:],linewidth = 2,label = "CO2")
	plt.plot(unp[7,:],linewidth = 2,label = "H2O")
	plt.xlabel("Time step", fontsize = 30)
	plt.ylabel("Number of negative values predicted", fontsize = 30)
	plt.legend(fontsize = 25)
	plt.show()



unphysical_values()